(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{604:function(t,e,s){"use strict";s.r(e);var a=s(17),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),s("h2",{attrs:{id:"为什么需要-websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-websocket"}},[t._v("#")]),t._v(" 为什么需要 WebSocket")]),t._v(" "),s("p",[t._v("在 WebSocket 出现之前，如果我们想实现实时通信，比较常采用的方式是 Ajax 轮询，即在特定时间间隔（比如每秒）由浏览器发出请求，服务器返回最新的数据。")]),t._v(" "),s("blockquote",[s("p",[t._v("Ajax 轮询原理: 让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。")])]),t._v(" "),s("blockquote",[s("p",[t._v("长轮询(long pull)原理，和 Ajax 轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。")])]),t._v(" "),s("p",[t._v("Ajax 轮询存在的缺陷")]),t._v(" "),s("ul",[s("li",[t._v("HTTP 请求一般包含的头部信息比较多，其中有效的数据可能只占很小的一部分，导致带宽浪费；")]),t._v(" "),s("li",[t._v("服务器被动接收浏览器的请求然后响应，数据没有更新时仍然要接收并处理请求，导致服务器 CPU 占用；")])]),t._v(" "),s("p",[t._v("WebSocket 可以解决上述问题")]),t._v(" "),s("ul",[s("li",[t._v("WebSocket 的头部信息少，通常只有 2Bytes 左右，能节省带宽；")]),t._v(" "),s("li",[t._v("WebSocket 支持服务端主动推送消息，更好地支持实时通信；")])]),t._v(" "),s("h2",{attrs:{id:"websocket-是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket-是什么"}},[t._v("#")]),t._v(" WebSocket 是什么")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("WebSocket 是基于 TCP 的一种新的应用层网络协议。它实现了浏览器与服务器全双工通信，即允许服务器主动发送信息给客户端。因此，在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。")])])]),t._v(" "),s("h3",{attrs:{id:"websocket-特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket-特点"}},[t._v("#")]),t._v(" WebSocket 特点")]),t._v(" "),s("ul",[s("li",[t._v("建立在 TCP 协议之上；")]),t._v(" "),s("li",[t._v("与 HTTP 协议有着良好的兼容性：默认端口也是 80（ws） 和 443(wss，运行在 TLS 之上)，并且握手阶段采用 HTTP 协议；")]),t._v(" "),s("li",[t._v("较少的控制开销：连接创建后，ws 客户端、服务端进行数据交换时，协议控制的数据包头部较小，而 HTTP 协议每次通信都需要携带完整的头部；")]),t._v(" "),s("li",[t._v("可以发送文本，也可以发送二进制数据；")]),t._v(" "),s("li",[t._v("没有同源限制，客户端可以与任意服务器通信；")]),t._v(" "),s("li",[t._v("协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL；")]),t._v(" "),s("li",[t._v("支持扩展：ws 协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议（比如支持自定义压缩算法等）；")])]),t._v(" "),s("h3",{attrs:{id:"html5-与-websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html5-与-websocket"}},[t._v("#")]),t._v(" HTML5 与 WebSocket")]),t._v(" "),s("p",[t._v("WebSocket API 是 HTML5 标准的一部分，但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如：")]),t._v(" "),s("ul",[s("li",[t._v("基于 C 的 libwebsocket.org")]),t._v(" "),s("li",[t._v("基于 Node.js 的 Socket.io")]),t._v(" "),s("li",[t._v("基于 Python 的 ws4py")]),t._v(" "),s("li",[t._v("基于 C++ 的 WebSocket++")]),t._v(" "),s("li",[t._v("Apache 对 WebSocket 的支持：Apache Module mod_proxy_wstunnel")]),t._v(" "),s("li",[t._v("Nginx 对 WebSockets 的支持：NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying")])]),t._v(" "),s("h2",{attrs:{id:"websocket-原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket-原理"}},[t._v("#")]),t._v(" WebSocket 原理")]),t._v(" "),s("h3",{attrs:{id:"如何建立连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何建立连接"}},[t._v("#")]),t._v(" 如何建立连接")]),t._v(" "),s("p",[t._v("在 WebSocket 开始通信之前，通信双方需要先进行握手，WebSocket 复用了 HTTP 的握手通道，即客户端通过 HTTP 请求与 WebSocket 服务端协商升级协议。协议升级完成后，后续的数据交换则遵照 WebSocket 的协议。\n利用 HTTP 完成握手有什么好处呢？一是可以让 WebSocket 和 HTTP 基础设备兼容（运行在 80 端口 或 443 端口），二是可以复用 HTTP 的 Upgrade 机制，完成升级协议的协商过程。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c39abcd4ab5d41b897f19041d68f8c4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?",alt:"WebSocket 连接"}})]),t._v(" "),s("ul",[s("li",[t._v("101 状态码，表示协议切换")]),t._v(" "),s("li",[t._v("Connection: Upgrade 表示要升级协议")]),t._v(" "),s("li",[t._v("Upgrade: websocket 表示要升级到 WebSocket 协议")]),t._v(" "),s("li",[t._v("Sec-WebSocket-Accept 需要经过服务器确认加密过后的 Sec-WebSocket-Key")]),t._v(" "),s("li",[t._v("Sec-WebSocket-Key：与服务端响应头部的 Sec-WebSocket-Accept 是配套的，提供基本的防护，比如恶意的连接，或者无意的连接；这里的“配套”指的是：Sec-WebSocket-Accept 是根据请求头部的 Sec-WebSocket-Key 计算而来，计算过程大致为基于 SHA1 算法得到摘要并转成 base64 字符串。")])]),t._v(" "),s("h3",{attrs:{id:"如何交换数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何交换数据"}},[t._v("#")]),t._v(" 如何交换数据")]),t._v(" "),s("p",[t._v("具体的数据格式是怎么样的呢？WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。")]),t._v(" "),s("p",[t._v("MDN 上的示例")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIN")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opcode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" msg"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Server")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("process complete message immediately"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Hi"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIN")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opcode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" msg"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"and a"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Server")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listening"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newmessage containing text started"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIN")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opcode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" msg"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"happy new"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Server")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("listening"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" payload concatenated to previous message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Client")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIN")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opcode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" msg"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"year!"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("Server")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("process complete message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Happy "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("year")]),t._v(" to you too"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("\n")])])]),s("p",[t._v("在该示例中，客户端向服务器发送了两条消息，第一个消息在单个帧中发送，而第二个消息跨三个帧发送。当 WebSocket 的接收方收到一个数据帧时，会根据 FIN 字段值来判断是否收到消息的最后一个数据帧。利用 FIN 和 Opcode，我们就可以实现跨帧发送消息。")]),t._v(" "),s("p",[t._v("其中 Opcode 表示操作码，它的可能值有:")]),t._v(" "),s("ul",[s("li",[t._v("0x1，传输数据是文本；")]),t._v(" "),s("li",[t._v("0x2，传输数据是二进制数据；")]),t._v(" "),s("li",[t._v("0x0，表示该帧是一个延续帧（这意味着服务器应该将帧的数据连接到从该客户端接收到的最后一个帧）；")]),t._v(" "),s("li",[t._v("0x3-7：保留的操作代码，用于后续定义的非控制帧；")]),t._v(" "),s("li",[t._v("0x8：表示连接断开；")]),t._v(" "),s("li",[t._v("0x9：表示这是一个心跳请求（ping）；")]),t._v(" "),s("li",[t._v("0xA：表示这是一个心跳响应（pong）；")]),t._v(" "),s("li",[t._v("0xB-F：保留的操作代码，用于后续定义的控制帧；")])]),t._v(" "),s("h3",{attrs:{id:"如何维持连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何维持连接"}},[t._v("#")]),t._v(" 如何维持连接")]),t._v(" "),s("p",[t._v("如果我们使用 WebSocket 进行通信，建立连接之后怎么判断连接正常没有断开或者服务是否可用呢？可以通过建立心跳机制，所谓心跳机制，就是定时发送一个数据包，让对方知道自己在线且正常工作，确保通信有效。如果对方无法响应，便可以弃用旧连接，发起新的连接了。")]),t._v(" "),s("p",[t._v("需要重连的场景可能包括：网络问题或者机器故障导致连接断开、连接没断但不可用了或者连接对端的服务不可用了等等。")]),t._v(" "),s("p",[t._v("发送方 -> 接收方：ping。")]),t._v(" "),s("p",[t._v("接收方 -> 发送方：pong。")]),t._v(" "),s("p",[t._v("ping 、pong 的操作，对应的是 WebSocket 的两个控制帧，Opcode 分别是 0x9、0xA")]),t._v(" "),s("h2",{attrs:{id:"websocket-使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket-使用场景"}},[t._v("#")]),t._v(" WebSocket 使用场景")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd15392198349649e3d9552bfc863d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?",alt:"WebSocket 使用场景"}})]),t._v(" "),s("h2",{attrs:{id:"参考文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.cn/post/7086021621542027271",target:"_blank",rel:"noopener noreferrer"}},[t._v("WebSocket｜概念、原理、用法及实践"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);