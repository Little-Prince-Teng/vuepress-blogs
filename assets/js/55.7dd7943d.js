(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{624:function(t,r,a){"use strict";a.r(r);var s=a(17),e=Object(s.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"组件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[t._v("#")]),t._v(" 组件通信")]),t._v(" "),a("h2",{attrs:{id:"父子组件通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子组件通信"}},[t._v("#")]),t._v(" 父子组件通信")]),t._v(" "),a("h3",{attrs:{id:"props-属性绑定-父组件向子组件传递数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props-属性绑定-父组件向子组件传递数据"}},[t._v("#")]),t._v(" props 属性绑定(父组件向子组件传递数据)")]),t._v(" "),a("h4",{attrs:{id:"prop-双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prop-双向绑定"}},[t._v("#")]),t._v(" prop 双向绑定")]),t._v(" "),a("p",[t._v("一般情况下，子组件不能直接修改从父组件接收的属性值，否则会报错；如果希望子组件 prop 父组件中的值改变时，将变化同步到父组件中，可使用事件监听或 "),a("strong",[t._v(".sync 修饰符")]),t._v("(.sync 修饰符是一个语法糖，本质上等同于事件监听的方法)")]),t._v(" "),a("h3",{attrs:{id:"监听子组件事件-子组件向父组件传递数据-子组件触发父组件方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听子组件事件-子组件向父组件传递数据-子组件触发父组件方法"}},[t._v("#")]),t._v(" 监听子组件事件(子组件向父组件传递数据，子组件触发父组件方法)")]),t._v(" "),a("p",[t._v("vue 实例方法 vm.$emit 子组件可以自定义一个事件提交给父组件，触发父组件的方法，父组件可以监听子组件的自定义事件可以接收子组件传递的数据")]),t._v(" "),a("h3",{attrs:{id:"使用-refs-父组件访问子组件的数据和方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-refs-父组件访问子组件的数据和方法"}},[t._v("#")]),t._v(" 使用 $refs(父组件访问子组件的数据和方法)")]),t._v(" "),a("p",[t._v("使用时需要在调用子组件时给子组件定义一个 ref 名")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("$refs 只会在组件渲染完成后生效，并且它们不是响应式的，应该避免在模版或计算属性中访问 $refs")]),t._v(" "),a("li",[t._v("由于 ref 需要在 DOM 渲染完成后才会有，在使用的时候确保 DOM 已经渲染完成，比如在生命周期 mounted() 钩子函数中调用，或者在 this.$nextTick() 中调用")])])]),t._v(" "),a("h3",{attrs:{id:"使用-parent-子组件访问父组件的数据和方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-parent-子组件访问父组件的数据和方法"}},[t._v("#")]),t._v(" 使用 $parent(子组件访问父组件的数据和方法)")])])}),[],!1,null,null,null);r.default=e.exports}}]);