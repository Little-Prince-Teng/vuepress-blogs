(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{608:function(a,t,e){"use strict";e.r(t);var s=e(17),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[a._v("#")]),a._v(" 浏览器缓存")]),a._v(" "),e("h2",{attrs:{id:"浏览器缓存过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存过程"}},[a._v("#")]),a._v(" 浏览器缓存过程")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c62c048f5164e7d8d98bcd4dba180b1~tplv-k3u1fbpfcp-watermark.image",alt:"缓存过程"}})]),a._v(" "),e("h2",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),e("p",[a._v("强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。")]),a._v(" "),e("h3",{attrs:{id:"expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),e("p",[a._v("缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点；需要和 Last-modified 结合使用；\nExpires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效；")]),a._v(" "),e("h3",{attrs:{id:"cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),e("p",[a._v("控制页面缓存；比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存；\n可以在请求头或响应头中设置并且可以组合多种指令；")]),a._v(" "),e("h4",{attrs:{id:"no-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#no-cache"}},[a._v("#")]),a._v(" no-cache")]),a._v(" "),e("p",[a._v("客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。\n需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致")]),a._v(" "),e("h4",{attrs:{id:"no-store"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#no-store"}},[a._v("#")]),a._v(" no-store")]),a._v(" "),e("p",[a._v("所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")]),a._v(" "),e("h4",{attrs:{id:"max-age"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#max-age"}},[a._v("#")]),a._v(" max-age")]),a._v(" "),e("p",[a._v("max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效")]),a._v(" "),e("h3",{attrs:{id:"expires-vs-cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires-vs-cache-control"}},[a._v("#")]),a._v(" Expires VS Cache-Control")]),a._v(" "),e("p",[a._v("区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。")]),a._v(" "),e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),e("p",[a._v("协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程")]),a._v(" "),e("h3",{attrs:{id:"两种情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两种情况"}},[a._v("#")]),a._v(" 两种情况")]),a._v(" "),e("ul",[e("li",[a._v("协商缓存生效，返回304和Not Modified")]),a._v(" "),e("li",[a._v("协商缓存失效，返回200和请求结果")])]),a._v(" "),e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),e("p",[a._v("协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。")]),a._v(" "),e("h3",{attrs:{id:"last-modified和if-modified-since"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified和if-modified-since"}},[a._v("#")]),a._v(" Last-Modified和If-Modified-Since")]),a._v(" "),e("p",[a._v("浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值就是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；\n浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。")]),a._v(" "),e("h3",{attrs:{id:"last-modified-的弊端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-的弊端"}},[a._v("#")]),a._v(" Last-Modified 的弊端")]),a._v(" "),e("ul",[e("li",[a._v("如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源")]),a._v(" "),e("li",[a._v("因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源")])]),a._v(" "),e("h3",{attrs:{id:"etag和if-none-match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag和if-none-match"}},[a._v("#")]),a._v(" ETag和If-None-Match")]),a._v(" "),e("p",[a._v("Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。")]),a._v(" "),e("h3",{attrs:{id:"etag-vs-last-modified"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-vs-last-modified"}},[a._v("#")]),a._v(" Etag VS Last-modified")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("首先在精确度上，Etag要优于Last-Modified。\nLast-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。")])]),a._v(" "),e("li",[e("p",[a._v("第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。")])]),a._v(" "),e("li",[e("p",[a._v("第三在优先级上，服务器校验优先考虑Etag")])])]),a._v(" "),e("h2",{attrs:{id:"参考文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/ljianshu/Blog/issues/23",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入理解浏览器的缓存机制"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);