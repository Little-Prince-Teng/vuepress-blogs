(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{588:function(t,a,v){"use strict";v.r(a);var _=v(17),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),v("h2",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("p",[t._v("当一个嵌套函数内部引用了其外部函数的变量，即使外部函数执行完毕，嵌套函数仍然可以访问和操作这些变量，这种引用关系形成了闭包\n闭包是函数及其相关的词法作用域组成的组合体。它使得函数可以访问其词法作用域之外的变量。")]),t._v(" "),v("h2",{attrs:{id:"面试中如何回答"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面试中如何回答"}},[t._v("#")]),t._v(" 面试中如何回答")]),t._v(" "),v("p",[t._v("闭包是指函数内部定义的函数，并且该内部函数可以访问其外部函数的作用域中的变量；换句话说，闭包允许一个函数捕获器其外部作用域中的变量，即使在外部函数执行完毕后，仍然可以访问到这些变量。")]),t._v(" "),v("p",[t._v("MDN对闭包的定义")]),t._v(" "),v("blockquote",[v("p",[t._v("闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合")])]),t._v(" "),v("p",[t._v("JS高级程序设计对闭包的定义")]),t._v(" "),v("blockquote",[v("p",[t._v("闭包是指有权访问另一个函数作用域中的变量的函数")])]),t._v(" "),v("p",[t._v("JS权威指南对闭包的定义")]),t._v(" "),v("blockquote",[v("p",[t._v('函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为"闭包"')])]),t._v(" "),v("h2",{attrs:{id:"用途"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用途"}},[t._v("#")]),t._v(" 用途")]),t._v(" "),v("ol",[v("li",[t._v("保持状态：闭包允许函数保持状态，即使函数执行完毕后仍然可以访问和修改其内部变量。这在需要跟踪状态或者记住某些信息的情况下非常有用，比如计数器、缓存、状态管理。")]),t._v(" "),v("li",[t._v("模块模式：通过使用闭包，可以模拟私有变量和方法，从而实现模块化的代码结构。这种模式可以避免全局命名空间的污染，提高代码的可维护性和可重用性。")]),t._v(" "),v("li",[t._v("封装实现：闭包可以将某些实现细节隐藏起来，只暴露必要的接口，从而实现封装性。这对于设计对象、类或者库时非常有用，可以有效地隐藏内部状态和方法。")]),t._v(" "),v("li",[t._v("回调函数：闭包经常用于创建回调函数，即在一个函数中定义另一个函数，并将其作为参数传递给其他函数。这样可以实现异步编程模式，处理事件处理程序、Ajax请求、定时器等")]),t._v(" "),v("li",[t._v("函数式编程：闭包是函数式编程的重要概念之一，它允许在函数内部操作函数，并能够捕获外部环境的状态。这种特性在函数式编程中常用于实现高阶函数、柯里化、函数组合等功能。")]),t._v(" "),v("li",[t._v("内存管理：闭包可以帮助管理内存，因为它们允许在函数执行完毕后继续保持对其作用域的引用。但是，需要注意避免出现内存泄漏的情况，即在不再需要时释放对闭包的引用。")])]),t._v(" "),v("h2",{attrs:{id:"词法作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[t._v("#")]),t._v(" 词法作用域")]),t._v(" "),v("p",[t._v("JavaScript 采用的是词法作用域，也就是静态作用域；即函数的作用域在函数定义的时候就决定了，而不是函数调用的时候。\n在词法作用域中，变量在被声明时的位置决定了它们在作用域链中的位置。当访问一个变量时，解释器会按照作用域链从内到外进行查找，直到找到第一个匹配的变量或达到全局作用域。")]),t._v(" "),v("h2",{attrs:{id:"执行上下文栈-execution-context-stack-ecs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈-execution-context-stack-ecs"}},[t._v("#")]),t._v(" 执行上下文栈（Execution context stack，ECS）")]),t._v(" "),v("p",[t._v("当执行(调用)一个函数的时候，就会创建该函数的执行上下文对象（Execution Context Object）来存储函数的变量、参数和其他执行相关的信息，这些执行上下文对象被压入执行上下文栈中，构成一个栈结构，函数执行完毕，对应的执行上下文对象会被弹出栈。")]),t._v(" "),v("p",[t._v("执行上下文栈的作用是管理函数调用的顺序和执行环境，这样函数的执行顺序和嵌套关系就可以得到维护。")]),t._v(" "),v("h2",{attrs:{id:"变量对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变量对象"}},[t._v("#")]),t._v(" 变量对象")]),t._v(" "),v("p",[t._v("每个执行上下文对象，都有三个重要属性：")]),t._v(" "),v("ol",[v("li",[t._v("变量对象(Variable object，VO)")]),t._v(" "),v("li",[t._v("作用域链(Scope chain)")]),t._v(" "),v("li",[t._v("this")])]),t._v(" "),v("h2",{attrs:{id:"函数上下文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数上下文"}},[t._v("#")]),t._v(" 函数上下文")]),t._v(" "),v("p",[t._v("在函数上下文中，用活动对象(activation object, AO)来表示变量对象。活动对象是进入函数上下文时被创建的")]),t._v(" "),v("h2",{attrs:{id:"执行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[t._v("#")]),t._v(" 执行过程")]),t._v(" "),v("ol",[v("li",[t._v("进入执行上下文")]),t._v(" "),v("li",[t._v("代码执行")])]),t._v(" "),v("h3",{attrs:{id:"进入执行上下文"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进入执行上下文"}},[t._v("#")]),t._v(" 进入执行上下文")]),t._v(" "),v("p",[t._v("当进入执行上下文时，这时候还没有执行代码，变量对象会包括：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("函数的所有参数")]),t._v(" "),v("ul",[v("li",[t._v("由名称和对应值整的一个变量对象的属性被创建")]),t._v(" "),v("li",[t._v("没有实参，属性值设为 undefined")])])]),t._v(" "),v("li",[v("p",[t._v("函数声明")]),t._v(" "),v("ul",[v("li",[t._v("由名称和对应值组成一个变量对象属性被创建")]),t._v(" "),v("li",[t._v("如果变量对象已经存在相同名称的属性，则完全替换这个属性")])])]),t._v(" "),v("li",[v("p",[t._v("变量声明")]),t._v(" "),v("ul",[v("li",[t._v("由名称和对应值组成一个变量对象的属性被创建")]),t._v(" "),v("li",[t._v("如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性")])])])]),t._v(" "),v("p",[t._v("举个例子")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("function foo(a) {\n  var b = 2;\n  function c() {}\n  var d = function() {};\n\n  b = 3;\n\n}\n\nfoo(1);\n")])])]),v("p",[t._v("在进入执行上下文后，这时候的AO是")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("AO = {\n    arguments: {\n        0: 1,\n        length: 1\n    },\n    a: 1,\n    b: undefined,\n    c: reference to function c(){},\n    d: undefined\n}\n")])])]),v("h3",{attrs:{id:"代码执行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码执行"}},[t._v("#")]),t._v(" 代码执行")]),t._v(" "),v("p",[t._v("在代码执行阶段，会顺序执行代码，根据代码，修改变量的值。上面的例子，当代码执行完后，这时候的AO是：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('AO = {\n    arguments: {\n        0: 1,\n        length: 1\n    },\n    a: 1,\n    b: 3,\n    c: reference to function c(){},\n    d: reference to FunctionExpression "d"\n}\n')])])]),v("h2",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),v("p",[t._v("在 JavaScript 中，当一个函数被定义时，它会创建一个闭包，闭包会捕获函数定义时所在的词法作用域，并保存对该环境中变量的引用。这样，即使函数在其定义环境之外被调用，它仍然可以访问和操作这些变量")]),t._v(" "),v("h2",{attrs:{id:"闭包的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包的作用"}},[t._v("#")]),t._v(" 闭包的作用")]),t._v(" "),v("ol",[v("li",[t._v("创建私有变量和方法")])]),t._v(" "),v("p",[t._v("通过闭包，可以模拟私有变量和私有方法的概念，将它们封装在函数内部，不被外部直接访问")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("实现模块化")])]),t._v(" "),v("p",[t._v("在模块化开发中，经常使用IIFE(立即执行函数表达式)来实现模块的封装。IIFE可以创建一个局部作用域，并且可以返回一个对象或函数，使外部无法访问内部的变量和函数")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[v("p",[t._v("块级作用域")])]),t._v(" "),v("li",[v("p",[t._v("防抖和节流")])])]),t._v(" "),v("p",[t._v("利用闭包来保存变量、计时器等状态")]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("实现函数柯里化")])]),t._v(" "),v("p",[t._v("通过闭包可以将一个接受多个参数的函数转换成一系列只接受部分参数的函数，实现柯里化的效果")]),t._v(" "),v("h2",{attrs:{id:"注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),v("ol",[v("li",[t._v("内存管理")])]),t._v(" "),v("p",[t._v("闭包会导致一些变量一直存在于内存中，不会被垃圾回收机制释放。需要小心处理，避免不必要的内存泄漏")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("性能影响")])]),t._v(" "),v("p",[t._v("由于闭包涉及变量引用和作用域链的查找，可能会对性能产生一定影响。因此，在大规模使用闭包时，需要注意其对性能的潜在影响")])])}),[],!1,null,null,null);a.default=e.exports}}]);