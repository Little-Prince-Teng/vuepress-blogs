(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{583:function(t,s,e){"use strict";e.r(s);var a=e(17),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),e("h2",{attrs:{id:"promise-对象的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象的特点"}},[t._v("#")]),t._v(" Promise 对象的特点")]),t._v(" "),e("ul",[e("li",[t._v("对象的状态不收外界影响。Promise 对象代表一个异步操作，有三种状态：pending(进行中)、fulfilled(已成功) 和 rejected(已失败)，只有异步操作的结果才可以决定当前的状态，任何其他操作都无法改变这个状态。")]),t._v(" "),e("li",[t._v("一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变只有两种可能：pending -> fulfilled 和 pending -> rejected")])]),t._v(" "),e("h2",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("ul",[e("li",[t._v("无法取消 Promise，一旦新建就会立即执行，无法中途取消")]),t._v(" "),e("li",[t._v("如果不设置回调函数，Promise 内部抛出的错误不会反应到外部")]),t._v(" "),e("li",[t._v("当处于 pending 状态时，无法得到目前进展到哪一个阶段")])]),t._v(" "),e("h2",{attrs:{id:"promise-prototype-then"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[t._v("#")]),t._v(" Promise.prototype.then()")]),t._v(" "),e("ul",[e("li",[t._v("then 方法第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数")]),t._v(" "),e("li",[t._v("then 方法返回的是一个新的 Promise 实例(不是原来的 Promise 实例)，因此可以采用链式写法")]),t._v(" "),e("li",[t._v("采用链式的 then ，可以指定一组按照次序调用的回调函数。这时前一个回调函数有可能返回的还是一个 Promise 对象(即有异步操作)，这是后一个回调函数，就会等待该 Promise 对象的状态发生改变，才会被调用")])]),t._v(" "),e("h2",{attrs:{id:"promise-prototype-catch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-catch"}},[t._v("#")]),t._v(" Promise.prototype.catch()")]),t._v(" "),e("ul",[e("li",[t._v("建议使用 catch() 方法，而不使用 then() 方法的第二个参数，理由是 catch() 写法可以捕获前面 then() 方法执行中的错误，也更接近同步的写法(try/catch)")]),t._v(" "),e("li",[t._v("如果没有使用 catch() 指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应")]),t._v(" "),e("li",[t._v("Promise 内部的错误不会影响到外部的代码")])]),t._v(" "),e("h2",{attrs:{id:"promise-prototype-finally"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-finally"}},[t._v("#")]),t._v(" Promise.prototype.finally()")]),t._v(" "),e("ul",[e("li",[t._v("指定不管 Promise 最后的状态如何，都会执行的操作，ES2018 引入的")]),t._v(" "),e("li",[t._v("finally() 不接受任何参数，与 Promise 状态无关")])]),t._v(" "),e("h2",{attrs:{id:"promise-all"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[t._v("#")]),t._v(" Promise.all()")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" p "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Promise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("all")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("p1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p2"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p3"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("ul",[e("li",[t._v("Promise.all() 接受一个数组作为参数，数组的每一项都是 Promise 对象，如果不是会先调用 Promise.resolved()，将参数转为 Promise 实例。Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例")]),t._v(" "),e("li",[t._v("Promise.all() 执行结果的状态由每一个 Promise 实例决定，存在两种情况：所有 Promise 实例都为 fulfilled，Promise.all() 执行结果的状态才会变成 fulfilled，此时每个 Promise 实例的返回值组成一个数组，传递给 Promise.all() 的回调函数；只要存在一个 Promise 实例被 rejected，Promise.all() 执行结果的状态就变成 rejected，此时第一个被 rejected 的 Promise 实例的返回值，会传递给 Promise.all() 的回调函数")])]),t._v(" "),e("h2",{attrs:{id:"promise-race"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[t._v("#")]),t._v(" Promise.race()")]),t._v(" "),e("ul",[e("li",[t._v("Promise.race() 参数和 Promise.all() 的参数一样")]),t._v(" "),e("li",[t._v("只要有一个 Promise 实例的状态发生改变，Promise.race() 执行结果的状态就跟着改变，率先改变的 Promise 实例的返回值，就传递给 Promise.race() 的回调函数")])]),t._v(" "),e("h2",{attrs:{id:"promise-allsettled"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled"}},[t._v("#")]),t._v(" Promise.allsettled()")]),t._v(" "),e("ul",[e("li",[t._v("ES2020引入的方法；用来确定一组异步操作是否都结束了(不管成功失败)")]),t._v(" "),e("li",[t._v("Promise.allsettled() 接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。")]),t._v(" "),e("li",[t._v("返回的新的 Promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象")])]),t._v(" "),e("h2",{attrs:{id:"promise-any"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-any"}},[t._v("#")]),t._v(" Promise.any()")]),t._v(" "),e("ul",[e("li",[t._v("ES2021 引入的，接受一组 Promise 实例作为参数")]),t._v(" "),e("li",[t._v("只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态")])]),t._v(" "),e("h2",{attrs:{id:"promise-resolved"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolved"}},[t._v("#")]),t._v(" Promise.resolved()")]),t._v(" "),e("ul",[e("li",[t._v("参数是一个 Promise 实例， Promise.resolved() 不作任何修改，原封不动的返回这个实例")]),t._v(" "),e("li",[t._v("参数是一个 thenabled 对象(具有 then 方法的对象)，Promise.resolved() 会将这个对象转为 Promise 对象，然后立即执行 thenabled 对象的 then 方法")]),t._v(" "),e("li",[t._v("参数不是具有 then 方法的对象，或根本不是对象，Promise.resolved() 返回一个新的 Promise 对象，状态为 resolved")]),t._v(" "),e("li",[t._v("不带任何参数，直接返回一个 resolved 状态的 Promise 对象")])]),t._v(" "),e("h2",{attrs:{id:"promise-reject"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[t._v("#")]),t._v(" Promise.reject()")]),t._v(" "),e("ul",[e("li",[t._v("返回一个新的 Promise 实例，该实例的状态为 rejected")])]),t._v(" "),e("h2",{attrs:{id:"promise-try"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-try"}},[t._v("#")]),t._v(" Promise.try()")]),t._v(" "),e("ul",[e("li",[t._v("让同步函数同步执行，异步函数异步执行，并且具有统一的 API")]),t._v(" "),e("li",[t._v("更好的管理异常")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'now'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nPromise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolved")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'next'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// next")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// now")]),t._v("\n")])])]),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'now'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nPromise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("try")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'next'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// now")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// next")]),t._v("\n")])])]),e("h2",{attrs:{id:"promise-then-第二个参数和-catch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-then-第二个参数和-catch-的区别"}},[t._v("#")]),t._v(" Promise then 第二个参数和 catch 的区别")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("如果是 Promise 内部报错，reject 抛出错误后，由于就近原则，then 的第二个参数会先捕获到异常，catch 则无法获取异常")])]),t._v(" "),e("li",[e("p",[t._v("如果是 then 的第一个参数抛出错误，then 的第一个参数捕获不到，后面的 catch 可以捕获到")])])]),t._v(" "),e("h2",{attrs:{id:"promise-解决回调函数地狱问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-解决回调函数地狱问题"}},[t._v("#")]),t._v(" Promise 解决回调函数地狱问题")]),t._v(" "),e("blockquote",[e("p",[t._v("回调函数地狱：多个回调函数嵌套，异步操作形成强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。")])]),t._v(" "),e("p",[e("strong",[t._v("Promise 可以将回调函数嵌套改成链式调用(then 方法)的方式")]),t._v(" "),e("strong",[t._v("Promise 可以将异步操作以同步操作的流程表达出来")])])])}),[],!1,null,null,null);s.default=r.exports}}]);