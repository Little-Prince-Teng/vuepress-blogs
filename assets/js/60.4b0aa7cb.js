(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{626:function(e,t,r){"use strict";r.r(t);var a=r(17),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue-项目中列表组件中-key-的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-项目中列表组件中-key-的作用"}},[e._v("#")]),e._v(" Vue 项目中列表组件中 key 的作用")]),e._v(" "),r("h2",{attrs:{id:"vue-官方文档-key-的用处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-官方文档-key-的用处"}},[e._v("#")]),e._v(" vue 官方文档 key 的用处")]),e._v(" "),r("blockquote",[r("ul",[r("li",[e._v("这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode")]),e._v(" "),r("li",[e._v("为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素")]),e._v(" "),r("li",[e._v("更新组件时判断新旧节点是否相同")])])]),e._v(" "),r("p",[r("strong",[e._v("Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。")])]),e._v(" "),r("p",[r("strong",[e._v("在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。")])]),e._v(" "),r("h2",{attrs:{id:"v-for-必须写-key-且不建议使用数组-index-作为-key-的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v-for-必须写-key-且不建议使用数组-index-作为-key-的原因"}},[e._v("#")]),e._v(" v-for 必须写 key，且不建议使用数组 index 作为 key 的原因")]),e._v(" "),r("ul",[r("li",[e._v("key 的作用主要是为了更高效的更新虚拟 DOM，因为可以准确的找到相同节点，patch 过程会非常高效")]),e._v(" "),r("li",[e._v("如果不设置 key，就可能认为两个节点是相同节点，只会做更新操作，会造成大量不必要的 DOM 操作")]),e._v(" "),r("li",[e._v("使用数组 index 作为 key，每个元素对应的位置关系都是 index，会插入元素后面的全部元素对应的位置关系都发生变化，会执行更新操作；使用相同标签过渡切换时，会导致只替换内部属性而不会触发过渡效果")])]),e._v(" "),r("h2",{attrs:{id:"参考文档"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[e._v("#")]),e._v(" 参考文档")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue 项目中列表组件中 key 的作用"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);