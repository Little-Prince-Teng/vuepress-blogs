(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{622:function(t,i,a){"use strict";a.r(i);var v=a(17),e=Object(v.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),a("p",[t._v("虚拟DOM中的差异比较算法(也称为diff算法)是用于比较新旧虚拟DOM树的差异，并找出需要更新的部分")]),t._v(" "),a("h2",{attrs:{id:"diff-算法的进化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法的进化"}},[t._v("#")]),t._v(" diff 算法的进化")]),t._v(" "),a("h3",{attrs:{id:"virtual-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[t._v("#")]),t._v(" virtual-dom")]),t._v(" "),a("p",[t._v("virtual-dom 作为虚拟 DOM 开天辟地的作品，采用了对 DOM 树进行了深度优先的遍历的方法。")]),t._v(" "),a("p",[t._v("子节点对比：需要对新的子节点进行重排序，先进行相同节点的 diff ，最后把子节点按照新的子节点顺序重新排列。")]),t._v(" "),a("h3",{attrs:{id:"cito-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cito-js"}},[t._v("#")]),t._v(" cito.js")]),t._v(" "),a("p",[t._v("cito 其他步骤与 virtual-dom 类似，最大的差异点就在子节点的对比上，而且 cito 移除了 patch 更新，在 diff 的过程中，直接更新真实 DOM ，这样省去了 patch 的存储，一定程度上节省了内存，后面其他的 VDOM 库基本使用这种方式。cito 主要变化就是引入了两端对比，将 diff 算法的速度提升了几个量级。")]),t._v(" "),a("h3",{attrs:{id:"kivi-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kivi-js"}},[t._v("#")]),t._v(" kivi.js")]),t._v(" "),a("p",[t._v("kivi 的 diff 算法在 cito 的基础上，引入了最长增长子序列，通过子序列找到最小的 DOM 操作数。")]),t._v(" "),a("h2",{attrs:{id:"降低时间复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#降低时间复杂度"}},[t._v("#")]),t._v(" 降低时间复杂度")]),t._v(" "),a("ul",[a("li",[t._v("前端框架的 diff 约定，只做同层对比，type 变了就不再对比子节点")]),t._v(" "),a("li",[t._v("两棵树做 diff，时间复杂度是 O(n^3)，因为每个节点都需要和另一棵树的全部节点对比，这就是 n 了，执行插入、删除、修改也是 n 的复杂度，所有节点都这样，再乘以 n，所以就是 O(n^3) 的复杂度；这样的复杂度对于前端框架来说是不可接受的")]),t._v(" "),a("li",[t._v("DOM 节点做跨层级移动的情况还是比较少的，一般情况都是同层级的 DOM 的增删改")]),t._v(" "),a("li",[t._v("整个 diff 算法的时间复杂度是 O(n)")])]),t._v(" "),a("h2",{attrs:{id:"减少-dom-操作次数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少-dom-操作次数"}},[t._v("#")]),t._v(" 减少 DOM 操作次数")]),t._v(" "),a("ul",[a("li",[t._v("一组节点，假设5个，类型是 ABCDE，下次渲染出来的是 EABCD，逐一对比，发现 type 不一样，就会重新渲染这5个节点，而且根据 type 不同就不再对比子节点的原则，如果这些节点有子节点，也会重新渲染；导致 DOM 操作比较慢，重新渲染的性能不高")]),t._v(" "),a("li",[t._v("每个节点都要有唯一的标识(key)，可以通过 key 来判断是否有节点发生了移动，从而直接复用")])]),t._v(" "),a("h2",{attrs:{id:"vue2-虚拟dom的diff算法做了哪些改进"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-虚拟dom的diff算法做了哪些改进"}},[t._v("#")]),t._v(" vue2 虚拟DOM的diff算法做了哪些改进")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用双端比较：Vue2.x中的diff算法使用了双端比较(Dual-pivot Diff)，从新旧节点的头部和尾部同时开始比较子节点，以尽量减少移动和交换操作")])]),t._v(" "),a("li",[a("p",[t._v("key的重用：Vue2.x中对key的处理更加优化，当相同层级的两个节点具有相同的key时，Vue会假设它们是可以复用的，从而避免重新创建和销毁节点，提高了性能")])]),t._v(" "),a("li",[a("p",[t._v("组件级别的比较：Vue2.x中的diff算法在组件级别上进行比较，而不是在整个应用程序级别上比较。这使得Vue可以更精确地定位到需要更新的组件，而不需要遍历整个组件树")])]),t._v(" "),a("li",[a("p",[t._v("异步更新队列：Vue2.x通过引入异步更新队列的概念，将多次更新操作合并为一次异步更新。这样可以批量处理更新，减少不必要的DOM操作，提高性能。")])])]),t._v(" "),a("h2",{attrs:{id:"vue3-diff-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-diff-优化"}},[t._v("#")]),t._v(" vue3 diff 优化")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("静态标记和提升：Vue3中引入了静态标记和静态提升的概念。编译器会在编译阶段对模版进行静态分析，将静态节点标记为静态，将静态节点的渲染结果提升为常量。这样可以减少运行时的比较和处理，提高渲染性能")])]),t._v(" "),a("li",[a("p",[t._v("静态节点的缓存：当一个静态节点被多次使用时，Vue3会对其进行缓存，只需要在第一次渲染时生成一次，后续的渲染会直接使用缓存的结果，避免重复生成和比较")])]),t._v(" "),a("li",[a("p",[t._v("使用最长递增子序列优化了对比流程：Vue2 里在 updateChildren() 函数里对比变更，在 Vue3 里这一块的逻辑主要在 patchKeyedChildren() 函数里")])]),t._v(" "),a("li",[a("p",[t._v("Fragments优化：Vue3优化了Fragments(片段)的处理逻辑，使其更加高效。Fragments允许在不额外创建父级节点的情况下渲染多个子节点。Vue3通过更好的跟踪和处理Fragments，减少了不必要的操作和比较")])])]),t._v(" "),a("h2",{attrs:{id:"vue3-里-patchkeyedchildren-diff方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-里-patchkeyedchildren-diff方式"}},[t._v("#")]),t._v(" vue3 里 patchKeyedChildren diff方式")]),t._v(" "),a("ul",[a("li",[t._v("头和头比")]),t._v(" "),a("li",[t._v("尾和尾比")]),t._v(" "),a("li",[t._v("基于最长递增子序列进行移动/添加/删除")])])])}),[],!1,null,null,null);i.default=e.exports}}]);